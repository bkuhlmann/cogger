:toc: macro
:toclevels: 5
:figure-caption!:

:format_link: link:https://ruby-doc.org/3.2.2/format_specifications_rdoc.html[String Format Specification]
:logger_link: link:https://rubyapi.org/o/s?q=Logger[Logger]
:pattern_matching_link: link:https://alchemists.io/articles/ruby_pattern_matching[pattern matching]
:rack_link: link:https://github.com/rack/rack[Rack]
:rfc_3339_link: link:https://datatracker.ietf.org/doc/html/rfc3339[RFC 3339]
:tone_link: link:https://alchemists.io/projects/tone[Tone]

= Cogger

Cogger is a portmanteau for custom logger (i.e. `[c]ustom + l[ogger] = cogger`) which enhances Ruby's native {logger_link} functionality with additional features such as dynamic emojis, colorized text, structured JSON, multiple streams, and much more. üöÄ

toc::[]

== Features

* Enhances Ruby's default {logger_link} with additional functionality and firepower.
* Provides customizable templates that use keys, emojis, and/or elements as an enhanced form of the {format_link}.
* Provides colored output via the {tone_link} gem.
* Provides customizable formatters.
* Provides multiple streams so you can log the same information to several outputs at once.
* Provides global and individual tagging.
* Provides filtering of sensitive information.
* Provides {rack_link} middleware for HTTP request logging.

== Screenshots

image::https://alchemists.io/images/projects/cogger/screenshots/demo.png[Rack,width=703,height=1151]

== Requirements

. link:https://www.ruby-lang.org[Ruby].

== Setup

To install _with_ security, run:

[source,bash]
----
# üí° Skip this line if you already have the public certificate installed.
gem cert --add <(curl --compressed --location https://alchemists.io/gems.pem)
gem install cogger --trust-policy HighSecurity
----

To install _without_ security, run:

[source,bash]
----
gem install cogger
----

You can also add the gem directly to your project:

[source,bash]
----
bundle add cogger
----

Once the gem is installed, you only need to require it:

[source,ruby]
----
require "cogger"
----

== Usage

All behavior is provided by creating an instance of `Cogger`. Example:

[source,ruby]
----
logger = Cogger.new
logger.info "Demo" # üü¢ [console] Demo
----

If you set your logging level to `debug`, you can walk through each level:

[source,ruby]
----
logger = Cogger.new level: :debug

# Without blocks.
logger.debug "Demo"                  # üîé [console] Demo
logger.info "Demo"                   # üü¢ [console] Demo
logger.warn "Demo"                   # ‚ö†Ô∏è [console] Demo
logger.error "Demo"                  # üõë [console] Demo
logger.fatal "Demo"                  # üî• [console] Demo
logger.unknown "Demo"                # ‚ö´Ô∏è [console] Demo
logger.any "Demo"                    # ‚ö´Ô∏è [console] Demo
logger.add Logger::INFO, "Demo"      # üü¢ [console] Demo

# With blocks.
logger.debug { "Demo" }              # üîé [console] Demo
logger.info { "Demo" }               # üü¢ [console] Demo
logger.warn { "Demo" }               # ‚ö†Ô∏è [console] Demo
logger.error { "Demo" }              # üõë [console] Demo
logger.fatal { "Demo" }              # üî• [console] Demo
logger.unknown { "Demo" }            # ‚ö´Ô∏è [console] Demo
logger.any { "Demo" }                # ‚ö´Ô∏è [console] Demo
logger.add(Logger::INFO) { "Demo" }  # üü¢ [console] Demo
----

The `[console]`, in the above output, is the program ID which is the ID of this gem's IRB console.

=== Initialization

When creating a new logger, you can configure behavior via the following attributes:

* `id`: The program/process ID which shows up in the logs as your `id`. Default: `$PROGRAM_NAME`. For example, if run within a `demo.rb` script, the `id` would be `"demo"`,
* `io`: The input/output stream. This can be `STDOUT/$stdout`, a file/path, or `nil`. Default: `$stdout`.
* `level`: The log level you want to log at. Can be `:debug`, `:info`, `:warn`, `:error`, `:fatal`, or `:unknown`. Default: `:info`.
* `formatter`: The formatter to use for formatting your log output. Default: `Cogger::Formatter::Color`. See the _Formatters_ section for more info.
* `tags`: The global tags used for all log entries. _Must_ be an array of objects you wish to use for tagging purposes. Default: `[]`.
* `datetime_format`: The global date/time format used for all `Time`, `Date`, and/or `DateTime` values in your log entries. Default: `%Y-%m-%dT%H:%M:%S.%L%:z`.
* `header`: Determines if your log files should start with a date/time header comment. Can be `true` or `false` and is identical to the `skip_header` functionality found in the {logger_link} class. Default: `true`. This is automatically disabled -- and can't be overwritten -- when using the JSON formatter since the JSON format doesn't support code comments.
* `mode`: The binary mode which determines if your logs should be written in binary mode or not. Can be `true` or `false` and is identical to the `binmode` functionality found in the {logger_link} class. Default: `false`.
* `age`: The rotation age of your log. This only applies when logging to a file. This is equivalent to the `shift_age` as found with the {logger_link} class. Default: `0`.
* `size`: The rotation size of your log. This only applies when logging to a file. This is equivalent to the `shift_size` as found with the {logger_link} class. Default: `1,048,576` (i.e. 1 MB).
* `suffix`: The rotation suffix. This only applies when logging to a file. This is equivalent to the `shift_period_suffix` as found with the {logger_link} class and is used when creating new rotation files. Default: `%Y-%m-%d`.

Given the above description, here's how'd you create a new logger instance with all attributes:

[source,ruby]
----
# Default
logger = Cogger.new

# Custom
logger = Cogger.new id: :demo,
                    io: "demo.log",
                    level: :debug,
                    formatter: :json,
                    tags: %w[DEMO DB],
                    datetime_format: "%Y-%m-%d",
                    header: false,
                    mode: false,
                    age: 5,
                    size: 1_000,
                    suffix: "%Y"
----

=== Levels

Supported levels can be obtained via `Cogger::LEVELS`. Example:

[source,ruby]
----
Cogger::LEVELS
# ["debug", "info", "warn", "error", "fatal", "unknown"]
----

=== Date/Time

The default date/time format used for _all_ log values can be viewed via the following:

[source,ruby]
----
Cogger::DATETIME_FORMAT
# "%Y-%m-%dT%H:%M:%S.%L%:z
----

The above adheres to {rfc_3339_link} and can be customized -- as mentioned earlier -- when creating a new logger instance. Example:

[source,ruby]
----
Cogger.new datetime_format: "%Y-%m-%d"
----

=== Environment

You can use your environment to define the desired default log level. The default log level is: `"info"`. Although, you can set the log level to any of the following:

[source,bash]
----
export LOG_LEVEL=debug
export LOG_LEVEL=info
export LOG_LEVEL=warn
export LOG_LEVEL=error
export LOG_LEVEL=fatal
export LOG_LEVEL=unknown
----

While downcase is preferred for each log level value, you can use upcased values as well. If the `LOG_LEVEL` environment variable is not set, `Cogger` will fall back to `"info"` unless overwritten during initialization. Example: `Cogger.new level: :debug`. Otherwise, an invalid log level will result in an `ArgumentError`.

=== Mutations

Each instance can be mutated using the following messages:

[source,ruby]
----
logger = Cogger.new io: StringIO.new

logger.close                                       # nil
logger.reopen                                      # Logger
logger.debug!                                      # 0
logger.info!                                       # 1
logger.warn!                                       # 2
logger.error!                                      # 3
logger.fatal!                                      # 4
logger.formatter = Cogger::Formatters::Simple.new  # Cogger::Formatters::Simple
logger.level = Logger::WARN                        # 2
----

Please see the {logger_link} documentation for more information.

=== Emojis

Emojis can be used to decorate and add visual emphasis to your logs. Here are the defaults:

[source,ruby]
----
Cogger.emojis

# {
#   :debug => "üîé",
#    :info => "üü¢",
#    :warn => "‚ö†Ô∏è",
#   :error => "üõë",
#   :fatal => "üî•",
#     :any => "‚ö´Ô∏è"
# }
----

The `:emoji` formatter is the default formatter which provides dynamic rendering of emojis based on log level. Example:

[source,ruby]
----
logger = Cogger.new
logger.info "Demo"

# üü¢ [console] Demo
----

To add multiple custom emojis, you can chain messages together when registering them:

[source,ruby]
----
Cogger.add_emojis tada: "üéâ", favorite: "‚ùáÔ∏è"
----

If you always want to use the _same_ emoji, you could use the emoji formatter with a specific template:

[source,ruby]
----
logger = Cogger.new formatter: Cogger::Formatters::Emoji.new("%<emoji:tada>s %<message:dynamic>s")

logger.info "Demo"
logger.warn "Demo"

# üéâ Demo
# üéâ Demo
----

As you can see, using a specific emoji will _always_ display regardless of the current log level.

üí° Emojis are used by the color and emoji formatters so check out the _Templates_ and _Formatters_ sections below to learn more.

=== Aliases

Aliases are specific to the {tone_link} gem which allows you _alias_ specific colors/styles via a new name. Here's how you can use them:

[source,ruby]
----
Cogger.add_alias :haze, :bold, :white, :on_purple
Cogger.aliases
----

The above would add a `:haze` alias which consists of bold white text on a purple background. Once added, you'd then be able to view a list of all default and custom aliases. You can also override an existing alias if you'd like something else.

Aliases are a powerful way to customize colors via concise syntax in your templates. Building upon the aliases, added above, you'd be able to use them in your templates as follows:

[source,ruby]
----
# Element
"<haze>%<message></haze>"

# Key
"%<message:haze>"
----

üí° Aliases are used by the color and emoji formatters so check out the {tone_link} documentation and/or _Templates_ and _Formatters_ sections below to learn more.

=== Encodings

All messages use UTF-8 encoding. Any unknown character will show up as a question mark. Example:

[source,ruby]
----
logger = Cogger.new
bad = "b\xE9d".dup.force_encoding "ASCII-8BIT"

logger.info bad      # "b?d"
logger.info { bad }  # "b?d"
----

The underlying implementation uses the following to produce the logs shown above:

[source,ruby]
----
message.encode "UTF-8", invalid: :replace, undef: :replace, replace: "?"
----

=== Templates

Templates are used by all formatters and adhere to an _enhanced_ version of the {format_link} as used by `Kernel#format`. Here‚Äôs what is provided by default:

[source,ruby]
----
Cogger.templates

# {
#   :color => "<dynamic>[%<id>s]</dynamic> %<message:dynamic>s",
#   :detail => "[%<id>s] [%<level>s] [%<at>s] %<message>s",
#   :emoji => "%<emoji:dynamic>s <dynamic>[%<id>s]</dynamic> %<message:dynamic>s",
#   :json => nil,
#   :property => nil,
#   :simple => "[%<id>s] %<message>s",
#   :rack => "[%<id>s] [%<level>s] [%<at>s] %<verb>s %<status>s %<duration>s %<ip>s %<path>s %<length># s %<params>s"
# }
----

All {format_link} specifiers, flags, width, and precision are supported except for the following restrictions:

* Use of _reference by name_ is required which means `%<demo>s` is allowed but `%{demo}` is not. This is because _reference by name_ is required for regular expressions and/or {pattern_matching_link}.
* Use of the `n$` flag is prohibited because it's not compatible with the above.

In addition to the above, the {format_link} is further enhanced with the use of keys, emojis, and/or elements. Each is explained in detail below.

==== Keys

Template keys works exactly as you'd expect when formatting a string using the {format_link} where each key in the template will be replaced with the corresponding attribute that matches the key. Example:

[source,ruby]
----
# Template
"%<level>s %<at>s %<id>s %<message>s"

# Output
# INFO 2024-08-25 10:44:58 -0600 console demo
----

Each key can be _enhanced_ further by delimiting the key with a colon and supplying a directive. Directives can be any of the following:

* *Dynamic*: Color is automatically calculated based on current log level.
* *Specific*: Color is specific/static while ignoring current log level.

Here's a few examples to illustrate:

[source,ruby]
----
# Dynamic
"%<level:dynamic>s %<at:dynamic>s %<id:dynamic>s %<message:dynamic>s"

# Specific
"%<level:purple>s %<at:yellow>s %<id:cyan>s %<message:green>s"
----

In the dynamic example, the color of each key is determined by current log level (i.e. info, warn, error, etc) which is looked up via the `Cogger.aliases` hash:

[source,ruby]
----
Cogger.aliases
# {
#   debug: %i[white],
#   info: %i[green],
#   warn: %i[yellow],
#   error: %i[red],
#   fatal: %i[bold white on_red],
#   any: %i[dim bright_white]
# }
----

In the specific example, the `level` is purple; `at` is yellow; `id` is cyan; and `message` is green. This is means you can mix-n-match dynamic and specific directives as desired:

[source,ruby]
----
"%<level:dynamic>s %<at:yellow>s %<id:dynamic>s %<message:green>s"
----

Assuming the current log level is _info_, then `level` is green; `at` is yellow; `id` is green; and `message` is green.

==== Emojis

Template emojis work similar to _keys_ but the `emoji` key is _special_ in that you can't use `emoji` as a key in your log messages. In other words the `emoji` key can only be used in templates. That said, emojis can be dynamic or specific. Example:

[source,ruby]
----
# Dynamic
"%<emoji:dynamic>s %<message:dynamic>s"

# Specific
"%<emoji:any>s %<message:dynamic>s"
----

In the dynamic example, the emoji is determined by current log level (i.e. info, warn, error, etc) which is looked up via the `Cogger.emojis` hash:

[source,ruby]
----
Cogger.emojis
# {
#   :debug => "üîé",
#    :info => "üü¢",
#    :warn => "‚ö†Ô∏è",
#   :error => "üõë",
#   :fatal => "üî•",
#     :any => "‚ö´Ô∏è"
# }
----

In the specific example, the emoji will be rendered exactly as defined.

==== Elements

Template elements are slightly different than _keys_ and _emojis_ in that they behave more like HTML elements. This means you can use open and close tags to use dynamic or specific colors. Example:

[source,ruby]
----
# Dynamic
"<dynamic>%<level>s %<at>s %<id>s %<message>s</dynamic>"

# Specific
"<purple>%<level>s %<at>s %<id>s %<message>s</purple>"
----

In the dynamic example, all characters within the template string will use the same color as determined by the current log level. In the specific example, all characters will be purple.

Using template elements, in this manner, keeps your templates simple when needing to apply the same color to multiple characters at once.

==== Combinations

Now that you know how template keys; emojis; and elements works, this means you can mix and match them in interesting combinations. Example:

[source,ruby]
----
"[%<id:purple>s] <dynamic>[%<level>s] [%<at>s]</dynamic> %<message:cyan>s"
----

The above will render as follows:

* The opening and closing brackets will be white (default color).
* The `id` will be purple.
* The `level` and `at` will be dynamic in color based on current log level (this includes the bracket characters).
* The `message` will be cyan.

==== Guidelines

Each log entry provides you with default keys you can use for the log event metadata in your templates. This stems from the fact that {logger_link} entries always have the following keys:

* `id`: The program/process ID you created your logger with (i.e. `Cogger.new id: :demo`).
* `level`: The level at which you messaged your logger (i.e. `Cogger#info`).
* `at`: The date/time as which your log event was created.

Additional keys as provided by your message hash and/or tags can be customized as desired but the above is _always_ available to you.

Template keys, emojis, and elements do have a few restrictions:

* Use the special `emoji` key to provide dynamic or specific emoji logging.
* Use the special `tags` key to provide tagged logging. More information on tags can be found later in this document.
* Avoid supplying the same keys as the default keys. Example: `logger.info id: :bad, at: Time.now, level: :bogus`. This is because these keys will be ignored. In other words, you can't _override_ the default keys.
* Avoid wrapping keys and/or emojis in elements because nesting isn't supported and can lead to strange output. Example: `<green>%<emoji:error>s %<id:dynamic>s</green>`.
* Avoid wrapping elements within elements because nesting isn't supported and can lead to strange output. Example: `<dynamic><cyan>%<message>s</cyan></dynamic>`.
* Avoid situations where a message hash doesn't match the keys in the template because an empty message will be logged instead. This applies to all formatters except the JSON formatter which will log any key/value that doesn't have a `nil` value.

=== Formatters

Multiple formatters are provided for you which can be further customized as needed. Here's what is provided by default:

[source,ruby]
----
Cogger.formatters

# {
#      :color => [
#     Cogger::Formatters::Color < Cogger::Formatters::Abstract,
#     "<dynamic>[%<id>s]</dynamic> %<message:dynamic>s"
#   ],
#     :detail => [
#     Cogger::Formatters::Simple < Cogger::Formatters::Abstract,
#     "[%<id>s] [%<level>s] [%<at>s] %<message>s"
#   ],
#      :emoji => [
#     Cogger::Formatters::Emoji < Cogger::Formatters::Color,
#     "%<emoji:dynamic>s <dynamic>[%<id>s]</dynamic> %<message:dynamic>s"
#   ],
#       :json => [
#     Cogger::Formatters::JSON < Cogger::Formatters::Abstract,
#     nil
#   ],
#   :property => [
#     Cogger::Formatters::Property < Cogger::Formatters::Abstract,
#     nil
#   ],
#     :simple => [
#     Cogger::Formatters::Simple < Cogger::Formatters::Abstract,
#     "[%<id>s] %<message>s"
#   ],
#       :rack => [
#     Cogger::Formatters::Simple < Cogger::Formatters::Abstract,
#     "[%<id>s] [%<level>s] [%<at>s] %<verb>s %<status>s %<duration>s %<ip>s %<path>s %<length>s # %<params>s"
#   ]
# }
----

You can add a formatter by providing a key, class, and _optional_ template. If a template isn't supplied, then the formatter's default template will be used instead (more on this shortly). Example:

[source,ruby]
----
# Registration

Cogger.add_formatter :basic, Cogger::Formatters::Simple, "%<level>s %<message>s"

# Usage

Cogger.get_formatter :basic
# [Cogger::Formatters::Simple, "%<level>s %<message>s"]

Cogger.get_formatter :bogus
# Unregistered formatter: bogus. (KeyError)
----

Symbols or strings can be used interchangeably when adding/getting formatters. As mentioned above, a template doesn't have to be supplied if you want to use the formatter's default template which can be inspected via `Cogger.templates` as mentioned earlier.

üí° When you find yourself customizing any of the default formatters, you can reduce typing by adding your custom configuration to the registry and then referring to it via it's associated key when initializing a new logger.

==== Simple

The simple formatter is a bare bones formatter that uses no color information and only supports basic {format_link} as mentioned in the _Templates_ section earlier. Example:

[source,ruby]
----
logger = Cogger.new formatter: :simple
----

This formatter can be used via the following template variations:

[source,ruby]
----
logger = Cogger.new formatter: :detail
logger = Cogger.new formatter: :rack
----

‚ÑπÔ∏è Any leading or trailing whitespace is automatically removed after the template has been formatted in order to account for template attributes that might be `nil` or empty strings so you don't have visual indentation in your output.

==== Color

The color formatter allows you to have color coded logs and can be used as follows:

[source,ruby]
----
logger = Cogger.new formatter: :color
----

Please refer back to the _Templates_ section on how to customize this formatter with more sophisticated templates. In addition to template customization, you can customize your color aliases as well. Default colors are provided by {tone_link} which are _aliased_ by log level:

[source,ruby]
----
Cogger.aliases

{
  debug: [:white],
  info: [:green],
  warn: [:yellow],
  error: [:red],
  fatal: %i[bold white on_red],
  any: [dim bright_white]
}
----

This allows a color -- or combination of color styles (i.e. foreground + background) -- to be dynamically applied based on log level. You can add additional aliases via:

[source,ruby]
----
Cogger.add_alias :mystery, :white, :on_purple
----

Once an alias is added, it can be immediately applied via the template of your formatter. Example:

[source,ruby]
----
# Applies the `mystery` alias universally to your template.
logger = Cogger.new formatter: Cogger::Formatters::Color.new("<mystery>%<message>s</mystery>")
----

‚ÑπÔ∏è Much like the simple formatter, any leading or trailing whitespace is automatically removed after the template has been formatted.

==== Emoji

The emoji formatter is enabled by default and is the equivalent of initializing with either of the following:

[source,ruby]
----
logger = Cogger.new
logger = Cogger.new formatter: :emoji
logger = Cogger.new formatter: Cogger::Formatters::Emoji.new
----

All of the above examples are identical so you can see how different formatters can be used and customized further. The default emojis are registered as follows:

[source,ruby]
----
Cogger.emojis

# {
#   :debug => "üîé",
#    :info => "üü¢",
#    :warn => "‚ö†Ô∏è",
#   :error => "üõë",
#   :fatal => "üî•",
#     :any => "‚ö´Ô∏è"
# }
----

This allows an emoji to be dynamically applied based on log level. You can add or modify aliases as follows:

[source,ruby]
----
Cogger.add_emojis warn: "üü°"
----

Once an alias is added/updated, it can be immediately applied via the template of your formatter. Example:

[source,ruby]
----
logger = Cogger.new
logger.warn "Demo"
# üü° [console] Demo
----

‚ÑπÔ∏è Much like the simple and color formatters, any leading or trailing whitespace is automatically removed after the template has been formatted.

==== Detail

This formatter is the _Simple_ formatter with a different template and can be configured as follows:

[source,ruby]
----
logger = Cogger.new formatter: :detail
----

==== Property

This formatter is similar in behavior to the _simple_ formatter except the template allows you to _order_ the layout of your keys. All other template information is ignored. Example:

*Default Order*

[source,ruby]
----
logger = Cogger.new formatter: :property

logger.info verb: "GET", path: "/"
# id=console level=INFO at=2024-08-28T14:47:09.447-06:00 verb=GET path=/
----

*Custom Order*

[source,ruby]
----
logger = Cogger.new formatter: Cogger::Formatters::Property.new("%<level>s %<verb>s")

logger.info verb: "GET", path: "/"
# level=INFO verb=GET id=console at=2024-08-28T14:49:13.861-06:00 path=/
----

Your template can be a full or partial match of keys. If no keys match what is defined in the template, then the original order of the keys will be used instead.

You can always supply a message as your first argument -- or specify it by using the `:message` key -- but is removed if not supplied which is why the above doesn't print a message in the output. To illustrate, the following are equivalent:

[source,ruby]
----
logger = Cogger.new formatter: :property

logger.info "Demo"
id=console level=INFO at=2024-08-28T14:50:01.990-06:00 message=Demo

logger.info message: "demo"
# id=console level=INFO at=2024-08-28T14:50:25.344-06:00 message=demo
----

When tags are provided, the `:tags` key will appear in the output depending on whether you are using _single tags_. If hash tags are used, they'll show up as additional attributes in the output. Here's an example where a mix of single and hash keys are used:

[source,ruby]
----
logger = Cogger.new formatter: :property

logger.info "Demo", tags: ["WEB", "PRIMARY", {service: :api, demo: true}]
# id=console
# level=INFO
# at=2024-08-28T14:51:06.600-06:00
# message=Demo
# tags="[WEB, PRIMARY]"
# service=api
# demo=true
----

Notice, with the above, that the single tags of `WEB` and `PRIMARY` show up in the `tags` stringified array while the `:service` and `:demo` keys show up at the top level of the hash. Since the `:tags`, `:service`, `:demo` keys are normal keys, like any key in your output, this means you can use a custom template to arrange the order of these keys if you don't like the default.

Emojis, spaces, tabs, new lines, and control characters will all be escaped and wrapped in quotes if detected for any value. Here's where the message has the special characters but this formatting would be applied to any value.

[source,ruby]
----
logger = Cogger.new formatter: :property

logger.info "‚òÄÔ∏è An example.\t\n \x1F"
# id=console level=INFO at=2024-08-28T15:03:24.107-06:00 message="\u2600\uFE0F An example.\t\n \x1F"
----

==== JSON

This formatter is similar in behavior to the _property_ formatter because you can _order_ the layout of your keys. All other template information is ignored, only the order of your template keys matters. Example:

*Default Order*

[source,ruby]
----
logger = Cogger.new formatter: :json

logger.info verb: "GET", path: "/"
# {"id":"console","level":"INFO","at":"2023-12-10T18:42:32.844+00:00","verb":"GET","path":"/"}
----

*Custom Order*

[source,ruby]
----
logger = Cogger.new formatter: Cogger::Formatters::JSON.new("%<level>s %<verb>s")

logger.info verb: "GET", path: "/"
# {"level":"INFO","verb":"GET","id":"console","at":"2023-12-10T18:43:03.805+00:00","path":"/"}
----

Your template can be a full or partial match of keys. If no keys match what is defined in the template, then the original order of the keys will be used instead.

You can always supply a message as your first argument -- or specify it by using the `:message` key -- but is removed if not supplied which is why the above doesn't print a message in the output. To illustrate, the following are equivalent:

[source,ruby]
----
logger = Cogger.new formatter: :json

logger.info "Demo"
# {"id":"console","level":"INFO","at":"2023-12-10T18:43:42.029+00:00","message":"Demo"}

logger.info message: "Demo"
# {"id":"console","level":"INFO","at":"2023-12-10T18:44:14.568+00:00","message":"Demo"}
----

When tags are provided, the `:tags` key will appear in the output depending on whether you are using _single tags_. If hash tags are used, they'll show up as additional attributes in the output. Here's an example where a mix of single and hash keys are used:

[source,ruby]
----
logger = Cogger.new formatter: :json

logger.info "Demo", tags: ["WEB", "PRIMARY", {service: :api, demo: true}]
# {
#   "id":"console",
#   "level":"INFO",
#   "at":"2023-12-10T18:44:32.723+00:00",
#   "message":"Demo",
#   "tags":["WEB",
#   "PRIMARY"],
#   "service":"api",
#   "demo":true
# }
----

Notice, with the above, that the single tags of `WEB` and `PRIMARY` show up in the `tags` array while the `:service` and `:demo` keys show up at the top level of the hash. Since the `:tags`, `:service`, `:demo` keys are normal keys, like any key in your JSON output, this means you can use a custom template to arrange the order of these keys if you don't like the default.

A block can be used with a string or hash for content. Example:

[source,ruby]
----
logger = Cogger.new formatter: :json

logger.info { "Demo" }
# {
#   "id":"console",
#   "level":"INFO",
#   "at":"2025-08-03T13:37:58.227-06:00",
#   "message":"Demo"
# }

logger.info { {message: :demo, weight: 0.2} }
# {
#   "id":"console",
#   "level":"INFO",
#   "at":"2025-08-03T13:39:32.438-06:00",
#   "message":"demo",
#   "weight":0.2
# }

logger.info(tags: %w[WEB PRIMARY]) { {message: :demo, weight: 0.2} }
# {
#   "id":"console",
#   "level":"INFO",
#   "at":"2025-08-03T13:42:22.869-06:00",
#   "message":"demo",
#   "tags":["WEB",
#   "PRIMARY"],
#   "weight":0.2
# }
----

==== Rack

This formatter is the _Simple_ formatter with a different template and can be configured as follows:

[source,ruby]
----
logger = Cogger.new formatter: :rack
----

==== Native

Should you wish to use the native formatter as provided by original/native {logger_link}, it will work but not in the manner you might expect. Example:

[source,ruby]
----
require "logger"

logger = Cogger.new formatter: Logger::Formatter.new
logger.info "Demo"

# I, [2024-08-28T15:57:31.930722 #69391]  INFO -- console: #<data Cogger::Entry id="console", level=:INFO, at=2024-08-28 15:57:31.930696 -0600, message="Demo", tags=[], datetime_format="%Y-%m-%dT%H:%M:%S.%L%:z", payload={}>
----

While the above doesn't cause an error, you only get a dump of the `Cogger::Entry` which is not what you want. To replicate native {logger_link} functionality, you can use the `Simple` formatter as follows:

[source,ruby]
----
formatter = Cogger::Formatters::Simple.new(
  "%<level>s, [%<at>s]  %<level>s -- %<id>s: %<message>s"
)
logger = Cogger.new(formatter:)
logger.info "Demo"

# INFO, [2023-10-15 15:07:13 -0600]  INFO -- console: Demo
----

The above is the rough equivalent of what {logger_link} provides for you by default.

==== Custom

Should none of the built-in formatters be to your liking, you can implement, use, and/or register a custom formatter as well. A minimum implementation would be to inherit from the `Abstract` superclass as follows:

[source,ruby]
----
class MyFormatter < Cogger::Formatters::Abstract
  TEMPLATE = "%<message>s"

  def initialize template = TEMPLATE
    super()
    @template = template
  end

  def call(*input)
    *, entry = input
    attributes = sanitize entry, :tagged

    "#{format(template, attributes).tap(&:strip!)}\n"
  end

  private

  attr_reader :template
end
----

There is no restriction on the dependencies you might want to inject into your custom formatter but -- at a minimum -- you'll want to provide a default template so it can be sanitized by the superclass. The only other requirement is that you must implement `#call` which takes a log entry which is an array of positional arguments (i.e. `level`, `at`, `id`, `entry`) and answers back a formatted string. If you need more examples you can look at any of the formatters provided within this gem.

=== Tags

Tags allow you to tag your messages at both a global and local (i.e. per message) level. _Please note that tags are mostly universal in behavior but can differ based on formatter used._ For example, here's a single global tag:

[source,ruby]
----
logger = Cogger.new tags: %w[WEB]
logger.info "Demo"

# üü¢ [console] [WEB] Demo
----

You can use multiple tags as well:

[source,ruby]
----
logger = Cogger.new tags: %w[WEB EXAMPLE]
logger.info "Demo"

# üü¢ [console] [WEB] [EXAMPLE] Demo
----

You are not limited to string-based tags. Any object will work:

[source,ruby]
----
logger = Cogger.new tags: ["ONE", :two, 3, {four: "FOUR"}, proc { "FIVE" }]
logger.info "Demo"

# üü¢ [console] [ONE] [two] [3] [FIVE] [four=FOUR] Demo
----

With the above, we have string, symbol, integer, hash, and proc tags. With hashes, you'll always get a the key/value pair formatted as: `key=value`. Procs/lambdas allow you to lazy evaluate your tag at time of logging which provides a powerful way to acquire the current process ID, thread ID, and so forth.

In addition to global tags, you can use local tags per log message. Example:

[source,ruby]
----
logger = Cogger.new
logger.info "Demo", tags: ["ONE", :two, 3, {four: "FOUR"}, proc { "FIVE" }]

# üü¢ [console] [ONE] [two] [3] [FIVE] [four=FOUR] Demo
----

You can also combine global and local tags:

[source,ruby]
----
logger = Cogger.new tags: ["ONE", :two]
logger.info "Demo", tags: [3, proc { "FOUR" }]

# üü¢ [console] [ONE] [two] [3] [FOUR] Demo
----

As you can see, tags are highly versatile. That said, the following guidelines are worth consideration when using them:

* Prefer uppercase tag names to make them visually stand out.
* Prefer short names, ideally 1-4 characters since long tags defeat the purpose of brevity.
* Prefer consistent tag names by using tags that are not synonymous or ambiguous.
* Prefer using tags by feature rather than things like environments. Examples: API, DB, MAILER.
* Prefer the JSON formatter for structured metadata instead of tags. Logging JSON formatted messages with tags will work but sticking with a traditional hash, instead of tags, will probably serve you better.

=== Filters

Filters allow you to mask sensitive information you don't want showing up in your logs. The default is an empty set:

[source,ruby]
----
Cogger.filters  # #<Set: {}>
----

To add filters, use:

[source,ruby]
----
Cogger.add_filters :login, "email"
Cogger.filters  # #<Set: {:login, :email}>
----

Symbols and strings can be used interchangeably but are stored as symbols since symbols are used when filtering log entries. Once your filters are in place, you can immediately see their effects:

[source,ruby]
----
Cogger.add_filters :password
logger = Cogger.new formatter: :json
logger.info login: "jayne", password: "secret"

# {
#   "id": "console",
#   "level": "INFO",
#   "at": "2024-08-28T16:09:26.132-06:00",
#   "login": "jayne",
#   "password": "[FILTERED]"
# }
----

=== Streams

You can add multiple log streams (outputs) by using:

[source,ruby]
----
logger = Cogger.new
               .add_stream(io: "tmp/demo.log")
               .add_stream(io: nil)

logger.info "Demo."
----

The above would log the `"Demo."` message to `$stdout` -- the default stream -- to the `tmp/demo.log` file, and to `/dev/null`. All attributes used to construct your default logger apply to all additional streams unless customized further. This means any custom template/formatter can be applied to your streams. Example:

[source,ruby]
----
logger = Cogger.new.add_stream(io: "tmp/demo.log", formatter: :json)
logger.info "Demo."
----

In this situation, you'd get colorized output to `$stdout` and JSON output to the `tmp/demo.log` file.

There is a lot you can do with streams. For example, if you wanted to experiment with the same message formatted by multiple formatters, you could add a stream per format. Example:

[source,ruby]
----
logger = Cogger.new
               .add_stream(formatter: :color)
               .add_stream(formatter: :detail)
               .add_stream(formatter: :json)
               .add_stream(formatter: :simple)

logger.info "Demo"

# üü¢ [console] Demo
# [console] Demo
# [console] [INFO] [2024-08-28T16:10:27.833-06:00] Demo
# {"id":"console","level":"INFO","at":"2024-08-28T16:10:27.833-06:00","message":"Demo"}
# [console] Demo
----

=== Abort

Aborting a program is mostly syntax sugar for Command Line Interfaces (CLIs) which aids in situations where you need to log an error message _and_ exit the program at the same time with an exit code of `1` (similar to how `Kernel#abort` behaves). This allows your CLI to log an error and ensure the exit status is correct when displaying status, piping commands together, etc. All of the arguments, when messaging `#error` directly, are the same. Here's how it works:

[source,ruby]
----
logger = Cogger.new

logger.abort "Danger!"
# üõë [console] Danger!
# Exits with status code: 1.

logger.abort { "Danger!" }
# üõë [console] Danger!
# Exits with status code: 1.

logger.abort message: "Danger!"
# üõë [console] Danger!
# Exits with status code: 1.
----

You can use `#abort` without a message which will not log anything and immediately exit:

[source,ruby]
----
logger.abort
# Logs no message and exits with status code: 1.
----

This is _not recommended_ since using `Kernel#exit` directly is more performant.

=== Rack

{rack_link} is _implicitly_ supported which means your middleware _must be_ Rack-based and _must require_ the Rack gem since `Cogger::Rack::Logger` doesn't _explicitly_ require Rack by default. If these requirements are met then, to add HTTP request logging, you only need to use it. Example:

[source,ruby]
----
use Rails::Rack::Logger
----

Like any other {rack_link} middleware, `Rails::Rack::Logger` is initialized with your current application along with any custom options. Example:

[source,ruby]
----
middleware = Cogger::Rack::Logger.new application
middleware.call environment
----

The following defaults are supported:

[source,ruby]
----
Cogger::Rack::Logger::DEFAULTS

# {
#   logger: Cogger.new(formatter: :json),
#   timer: Cogger::Time::Span.new,
#   :key_map => {
#       :verb => "REQUEST_METHOD",
#         :ip => "REMOTE_ADDR",
#       :path => "PATH_INFO",
#     :params => "QUERY_STRING",
#     :length => "CONTENT_LENGTH"
#   }
# }
----

The defaults can be customized. Example:

[source,]
----
Cogger::Rack::Logger.new application, {logger: Cogger.new}
----

In the above example, we see `Cogger.new` overrides the default `Cogger.new(formatter: :json)`. In practice, you'll want to customize the logger and key map. Here's how each default is configured to be used:

* `logger`: Defaults to JSON formatted logging but you'll want to pass in the same logger as globally configured for your application in order to reduce duplication and save on memory.
* `timer`: The timer calculates the total duration of the request and defaults to nanosecond precision but you can swap this out with your own timer if desired. When providing your own timer, the only requirement is that the timer respond to the `#call` message with a block.
* `key_map`: The key map is used to map the HTTP Headers to keys (i.e. tags) used in the log output. You can use the existing key map, provide your own, or use a hybrid.

Once this middleware is configured and used within your application, you'll start seeing the following kinds of log entries (depending on your specific settings and tags used):

[source,json]
----
{
  "id":"demo",
  "level":"INFO",
  "at":"2023-12-10T22:37:06.341+00:00",
  "verb":"GET",
  "ip":"127.0.0.1",
  "path":"/dashboard",
  "status":200,
  "duration":83,
  "unit":"ms"
}
----

*Rails*

To build upon the above -- and if using the Rails framework -- you could configure your application as follows:

[source,ruby]
----
# demo/config/application.rb
module Demo
  class Application < Rails::Application
    config.logger = Cogger.new id: :demo, formatter: :json,
    config.middleware.swap Rails::Rack::Logger, Cogger::Rack::Logger, {logger: config.logger}
  end
end
----

The above defines `Cogger` as the default logger for the entire application, ensures `Cogger::Rack::Logger` is configured to use it and swaps itself with the default `Rails::Rack::Logger` so you don't have two pieces of middleware logging the same HTTP requests.

Alternatively, you could use a more advanced configuration with even more detailed logging:

[source,ruby]
----
# demo/config/application.rb
module Demo
  class Application < Rails::Application
    config.version = ENV.fetch "PROJECT_VERSION"

    config.logger = Cogger.new id: :demo,
                               formatter: :json,
                               tags: [
                                 proc { {pid: Process.pid, thread: Thread.current.object_id} },
                                 {team: "acme", version: config.version}
                               ]

    unless Rails.env.test?
      config.middleware.swap Rails::Rack::Logger, Cogger::Rack::Logger, {logger: config.logger}
    end
  end
end
----

The above does the following:

* Fetches the project version from the environment and then logs the version as a tag.
* PID and thread information are dynamically calculated at runtime, via the proc, as tags too.
* Team information is also captured as a tag.
* The middleware is only configured for use in any environment other than the test environment.

You could also add the following to your Development and Test environments so you capture all logs in a log file:

[source,ruby]
----
# Add this to your development and/or test environment configuration.
config.logger = Cogger.new io: Rails.root.join("log/#{Rails.env}.log")
----

=== Defaults

Should you ever need quick access to the defaults, you can use:

[source,ruby]
----
Cogger.defaults
----

This is primarily meant for display/inspection purposes, though.

=== Inspection

Each instance can be inspected via the `#inspect` message:

[source,ruby]
----
logger = Cogger.new
logger.inspect

# "#<Cogger::Hub @id=console,
#                @io=IO,
#                @level=1,
#                @formatter=Cogger::Formatters::Emoji,
#                @datetime_format=\"%Y-%m-%dT%H:%M:%S.%L%:z\",
#                @tags=[],
#                @header=true,
#                @mode=false,
#                @age=,
#                @size=1048576,
#                @suffix=\"%Y-%m-%d\",
#                @entry=Cogger::Entry,
#                @logger=Logger>"
----

You can also look at individual attributes:

[source,ruby]
----
logger = Cogger.new

logger.id      # "console"
logger.io      # #<IO:<STDOUT>>
logger.tags    # []
logger.mode    # false
logger.age     # 0
logger.size    # 1048576
logger.suffix  # "%Y-%m-%d"

logger.level      # 1
logger.formatter  # Cogger::Formatters::Emoji
logger.debug?     # false
logger.info?      # true
logger.warn?      # true
logger.error?     # true
logger.fatal?     # true
----

=== Testing

When testing, you might find it convenient to rewind and read from the stream you are writing too (i.e. `IO`, `StringIO`, `File`). For instance, here is an example where I inject the default logger into my `Demo` class and then, for testing purposes, create a new logger to be injected which only logs to `StringIO` so I can buffer and read for test verification:

[source,ruby]
----
class Demo
  def initialize logger: Cogger.new
    @logger = logger
  end

  def call(text) = logger.info { text }

  private

  attr_reader :logger
end

RSpec.describe Demo do
  subject(:demo) { described_class.new logger: }

  let(:logger) { Cogger.new io: StringIO.new }

  describe "#call" do
    it "logs message" do
      demo.call "Test."
      expect(logger.reread).to include("Test.")
    end
  end
end
----

The ability to `#reread` is only available for the default (first) stream and doesn't work with any additional streams that you add to your logger. That said, this does make it easy to test the `Demo` implementation while also keeping your test suite output clean at the same time. üéâ

== Development

To contribute, run:

[source,bash]
----
git clone https://github.com/bkuhlmann/cogger
cd cogger
bin/setup
----

You can also use the IRB console for direct access to all objects:

[source,bash]
----
bin/console
----

Lastly, there is a `bin/demo` script which displays multiple log formats for quick visual reference. This is the same script used to generate the screenshots shown at the top of this document.

== Tests

To test, run:

[source,bash]
----
bin/rake
----

== link:https://alchemists.io/policies/license[License]

== link:https://alchemists.io/policies/security[Security]

== link:https://alchemists.io/policies/code_of_conduct[Code of Conduct]

== link:https://alchemists.io/policies/contributions[Contributions]

== link:https://alchemists.io/policies/developer_certificate_of_origin[Developer Certificate of Origin]

== link:https://alchemists.io/projects/cogger/versions[Versions]

== link:https://alchemists.io/community[Community]

== Credits

* Built with link:https://alchemists.io/projects/gemsmith[Gemsmith].
* Engineered by link:https://alchemists.io/team/brooke_kuhlmann[Brooke Kuhlmann].
